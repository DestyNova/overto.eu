<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Programming languages - Over to you</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="Programming languages"><meta itemprop=description content="Ever since getting a Commodore 64 as a kid around 1990 and reading the user’s manual from cover to cover, I’ve always enjoyed programming, and learning new languages and concepts. Here’s some of the ones I’ve played with in more recent years.
Contents Picat Picat and SAT/CP solving Optimal plan search with Picat’s planner Other Picat programs and libraries Nim Nim programs Haskell Haskell programs Ur/web Ur/web programs / utilities Picat Picat is a really interesting language in the Prolog family, which adds imperative and convenience features like list comprehensions and mutable maps and arrays."><meta itemprop=datePublished content="2023-12-31T03:41:31+00:00"><meta itemprop=dateModified content="2023-12-31T03:41:31+00:00"><meta itemprop=wordCount content="1227"><meta itemprop=keywords content><meta property="og:title" content="Programming languages"><meta property="og:description" content="Ever since getting a Commodore 64 as a kid around 1990 and reading the user’s manual from cover to cover, I’ve always enjoyed programming, and learning new languages and concepts. Here’s some of the ones I’ve played with in more recent years.
Contents Picat Picat and SAT/CP solving Optimal plan search with Picat’s planner Other Picat programs and libraries Nim Nim programs Haskell Haskell programs Ur/web Ur/web programs / utilities Picat Picat is a really interesting language in the Prolog family, which adds imperative and convenience features like list comprehensions and mutable maps and arrays."><meta property="og:type" content="article"><meta property="og:url" content="https://overto.eu/pages/languages/"><meta property="article:section" content="pages"><meta property="article:published_time" content="2023-12-31T03:41:31+00:00"><meta property="article:modified_time" content="2023-12-31T03:41:31+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Programming languages"><meta name=twitter:description content="Ever since getting a Commodore 64 as a kid around 1990 and reading the user’s manual from cover to cover, I’ve always enjoyed programming, and learning new languages and concepts. Here’s some of the ones I’ve played with in more recent years.
Contents Picat Picat and SAT/CP solving Optimal plan search with Picat’s planner Other Picat programs and libraries Nim Nim programs Haskell Haskell programs Ur/web Ur/web programs / utilities Picat Picat is a really interesting language in the Prolog family, which adds imperative and convenience features like list comprehensions and mutable maps and arrays."><link rel=stylesheet type=text/css media=screen href=https://overto.eu/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://overto.eu/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://overto.eu/css/dark.css><script src=https://overto.eu/js/main.js></script></head><body><div class="container wrapper"><div class=header><h1 class=site-title><a href=https://overto.eu/>Over to you</a></h1><div class=site-description><nav class="nav social"><ul class=flat><span class=scheme-toggle><a href=# id=scheme-toggle></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/pages/learning>Learning</a></li><li><a href=/tags/music>Music</a></li><li><a href=/pages/languages>Programming languages</a></li><li><a href=/pages/software>Software</a></li><li><a href=/tags/tech>Tech</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>31</span>
<span class=rest>Dec 2023</span></div></div><div class=matter><h1 class=title>Programming languages</h1></div></div><div class=paragraph><p>Ever since getting a Commodore 64 as a kid around 1990 and reading the user’s manual from cover to cover, I’ve always enjoyed programming, and learning new languages and concepts. Here’s some of the ones I’ve played with in more recent years.</p></div><div class=paragraph><aside><header><h4>Contents</h4></header><div style="border:thin dashed #b0e0e6;background:darkslategrey"><nav id=TableOfContents><ul><li><a href=#_picat>Picat</a><ul><li><a href=#_picat_and_satcp_solving>Picat and SAT/CP solving</a></li><li><a href=#_optimal_plan_search_with_picats_planner>Optimal plan search with Picat’s planner</a></li><li><a href=#_other_picat_programs_and_libraries>Other Picat programs and libraries</a></li></ul></li><li><a href=#_nim>Nim</a><ul><li><a href=#_nim_programs>Nim programs</a></li></ul></li><li><a href=#_haskell>Haskell</a><ul><li><a href=#_haskell_programs>Haskell programs</a></li></ul></li><li><a href=#_urweb>Ur/web</a><ul><li><a href=#_urweb_programs_utilities>Ur/web programs / utilities</a></li></ul></li></ul></nav></div></aside></div><div class=sect1><h2 id=_picat><a href=http://picat-lang.org>Picat</a></h2><div class=sectionbody><div class=paragraph><p>Picat is a really interesting language in the Prolog family, which adds imperative and convenience features like list comprehensions and mutable maps and arrays. It also includes a built-in constraint solver and SAT solver module, as well as support for calling out to external <a href=https://freuder.wordpress.com/2021/03/18/comparing-cp-and-mip>MIP and SMT solvers</a> like <a href=https://github.com/coin-or/Cbc>Cbc</a> and <a href=https://github.com/Z3Prover/z3>z3</a>.</p></div><div class=sect2><h3 id=_picat_and_satcp_solving>Picat and SAT/CP solving</h3><div class=paragraph><p>I’ve rarely had success with the MIP and SMT modules — perhaps it encodes the problems in a way that isn’t optimal for those solvers — but have had great success with <code>cp</code> and <code>sat</code>. For smaller problems, <code>cp</code> will often return a solution almost immediately, but quickly becomes intractable in situations where <code>sat</code> can produce a solution in just a few seconds.</p></div><div class=paragraph><p>What’s great about these solvers is their flexibility in solving many different kinds of problems, and (depending on the type of problem) it’s generally pretty easy to convert a brute-force program into one that uses the solver to exclude huge parts of the search space quickly. It’s also easy to ask the solver to try to maximise or minimise variables.</p></div><div class=sect3><h4 id=_satcp_programs>SAT/CP programs</h4><div class=ulist><ul><li><p><a href=https://github.com/DestyNova/advent_of_code_2023/blob/main/5/part2.pi>Advent of Code 2023, day 5 (part 2)</a></p></li><li><p><a href=https://github.com/DestyNova/advent_of_code_2023/blob/main/24/part2.pi>AoC 2023, day 24 (part 2)</a> — it came in really handy here since I didn’t have good enough maths skills to invent a "proper" solution. Instead, I just described the problem for the SAT solver and it produced the correct solution in a few seconds, getting me my first sub-1000 leaderboard result from the year’s puzzles.</p></li></ul></div></div></div><div class=sect2><h3 id=_optimal_plan_search_with_picats_planner>Optimal plan search with Picat’s planner</h3><div class=paragraph><p>Picat also includes a <code>planner</code> module which searches for optimal action plans by just defining how to transition from one state to all possible next states, and how to know if you’ve reached a goal state. You can also define a heuristic function like you would when implementing <a href=https://en.wikipedia.org/wiki/A*_search_algorithm>A*</a> to search the (potentially infinite) graph of actions and states. I’ve had some success with <code>planner</code> although it has sometimes led to very high memory consumption.</p></div><div class=sect3><h4 id=_planner_programs>Planner programs</h4><div class=ulist><ul><li><p><a href=https://github.com/DestyNova/advent_of_code_2023/blob/main/17/part2.pi>AoC 2023, day 17</a> — the part 2 solution worked, but took 26 minutes compared to a <a href=https://github.com/DestyNova/advent_of_code_2023/blob/main/17/part2_dijkstra.pi>Dijkstra implementation</a> that took 2 minutes. I tried an A* implementation as well, but it took 4 minutes, even though my <a href=https://github.com/DestyNova/advent_of_code_2023/blob/main/17/part2.nim>Nim version</a> only took around half a second — probably an implementation error on my part.</p></li><li><p><a href=https://github.com/DestyNova/advent_of_code_2023/blob/main/23/part1.pi>AoC 2023, day 23 (part 1)</a> — found an optimal solution with <code>planner</code> in 80 seconds, but it couldn’t handle part 2 due to memory usage.</p></li></ul></div></div></div><div class=sect2><h3 id=_other_picat_programs_and_libraries>Other Picat programs and libraries</h3><div class=ulist><ul><li><p><a href=https://github.com/DestyNova/picat_rational/tree/main>picat_rational</a> — a small module providing arbitrary-precision rational arithmetic functions. I wrote this while working on a <a href="https://projecteuler.net/problem=751">Project Euler problem</a> that called for rational arithmetic.</p></li></ul></div></div></div></div><div class=sect1><h2 id=_nim>Nim</h2><div class=sectionbody><div class=paragraph><p>This language crossed my radar a few years ago with people describing it as "Python-like" but with static, inferred types, and much faster. Upon playing with it, I decided it wasn’t very Python-like (check out <a href=https://github.com/actonlang/acton>Acton</a> if you’re really into that though), but it certainly was much faster and had static type inference. My brain seemed to put it into a similar hash slot as <a href=https://crystal-lang.org/>Crystal</a> even though they are different in many ways. Crystal is a little more terse and less syntactically noisy, but Nim is really elegant and incredibly memory efficient. The slightly higher level of syntactic/type noise (e.g. needing to declare types in function headers) provides extremely fast compile times in return, and the standard library is fantastic, at least for my needs so far. The default package manager <a href=https://github.com/nim-lang/nimble>Nimble</a> is also excellent.</p></div><div class=paragraph><p>At the moment I’d say Nim is my favourite general-purpose language to work with, presenting an excellent balance between conciseness, expressivity, reliability, performance and usability.</p></div><div class=sect2><h3 id=_nim_programs>Nim programs</h3><div class=ulist><ul><li><p><a href=https://github.com/DestyNova/nimplication>Nimplication</a>, a SAT solver using DPLL.</p></li><li><p><a href=https://github.com/DestyNova/vfconcat>vfconcat</a> — generate videos from PNG frames with inconsistent durations, using <a href=https://ffmpeg.org>ffmpeg</a>.</p></li><li><p>Almost all my solutions for <a href=https://github.com/DestyNova/advent_of_code_2022>Advent of Code 2022</a> are in Nim, and it was frankly a joy to work with. I missed some of the functional features and terseness of Haskell from previous years, but Nim just refused to get in my way and offered some nice functional features in the <a href=https://nim-lang.org/docs/sequtils.html>sequtils</a> library, as well as very efficient implementations of sets, heaps and maps.</p></li></ul></div></div></div></div><div class=sect1><h2 id=_haskell>Haskell</h2><div class=sectionbody><div class=paragraph><p>I’ve been interested in Haskell for many, many years, and made several attempts to get into it. The first few ended in confusing failure where my brain just didn’t feel big enough to really grok it, but eventually some of the concepts made sense.</p></div><div class=sect2><h3 id=_haskell_programs>Haskell programs</h3><div class=ulist><ul><li><p>Almost all my solutions for <a href=https://github.com/DestyNova/advent_of_code_2021>Advent of Code 2021</a> and <a href=https://github.com/DestyNova/advent_of_code_2020>2020</a> are in Haskell, and I learned a lot and had fun during the process. Most of the time it felt like an excellent tool for the job, but it felt suddenly very unwieldy when an obvious solution requiring heavy mutation was not straightforward to implement in pure Haskell. Eventually I figured out how to use <code>STArray</code>, but really missed mutable hashmaps, and debugging <code>ST</code> programs was awful since you can’t just drop in a <code>print</code> command anywhere you like.</p></li></ul></div></div></div></div><div class=sect1><h2 id=_urweb><a href=https://github.com/urweb/urweb>Ur/web</a></h2><div class=sectionbody><div class=paragraph><p>This <a href=https://programming-group.com/assets/pdf/papers/2020_A-Survey-of-Multitier-Programming.pdf>multitier, aka tierless</a> programming language builds on <a href=https://en.wikipedia.org/wiki/Standard_ML>Standard ML</a> (an influential language that isn’t popular nowadays but its ideas directly influenced <a href=https://ocaml.org>Ocaml</a> and probably Haskell too). The key idea is that it would be nice not to have to (manually) break up your program into frontend, backend and database layers, since that separation necessitates significant duplication of effort and tends to introduce errors, like:</p></div><div class=ulist><ul><li><p>Changing a field name in the DB and backend, but the frontend is still expecting the old name in the JSON.</p></li><li><p>Broken links in the frontend.</p></li><li><p>Incorrectly parsing requests received from the frontend (mismatch in number or types of parameters)</p></li></ul></div><div class=paragraph><p>Ur/web tries to solve this by allowing you to mix frontend and backend code in the same file (or even the same function), using the advanced type system to "slice" it apart automatically and transpile frontend-related code to Javascript. It also prevents many kinds of robustness and security errors like SQL injections and CSRF attacks.</p></div><div class=paragraph><p>It’s extremely frugal and compiles your web programs into small binaries that can be proxied behind a server like Nginx. Unfortunately, it’s very hard for beginners to get started. The best source of documentation is the <a href=http://www.impredicative.com/ur/demo/>official demos</a> which are very helpful, but it still feels hard to understand any of the documentation without being an expert in the ML language family, and especially SML since it relies on notions of modules and functors that seem to originate there. The language manual is written in a very mathematical, academic style. As a result, participation seems to be minimal due to those accessibility barriers. I would love to see more activity around Ur/web but the community appears to have dried up, and the project isn’t welcoming for people who don’t have a heavy ML/FP background.</p></div><div class=sect2><h3 id=_urweb_programs_utilities>Ur/web programs / utilities</h3><div class=ulist><ul><li><p><a href=https://github.com/DestyNova/memvalid>memvalid</a>, a stateless little utility for memorising text from scripts, songs etc. It was hosted on Heroku until they pulled their free tier.</p></li><li><p>A <a href=https://hub.docker.com/r/destynova/urweb>Docker Hub</a> image of Ur/web from 2021. Might be broken.</p></li></ul></div></div></div></div><hr class=footer-separator><div class=tags></div><div class=back><a href=https://overto.eu/><span aria-hidden=true>← Back</span></a></div><div class=back></div></div></div><hr style="height:10px;border:0;box-shadow:0 10px 10px -10px #8c8b8b inset"><section class=section><script src=https://utteranc.es/client.js repo=DestyNova/overto.eu issue-term=pathname label=comment theme=gruvbox-dark crossorigin=anonymous async></script></section><div class="footer wrapper"><nav class=nav><div>2023</div></nav></div></body></html>